CREATE DATABASE WINDOW ;
--WINDOW FUNCTIONS : ANALYTIC FUNCTION 
-- WINDOW FUNCTIONS ARE USED TO CREATE A WINDOW OF THE RECORDS 


-- Creation of Employees table And Inserting Values into it 
CREATE TABLE EMPLOYEES(
EMP_ID INT PRIMARY KEY ,
EMP_NAME VARCHAR(50) ,
DEPT_NAME VARCHAR(50) ,
SALARY INTEGER ) ;

INSERT INTO EMPLOYEES VALUES(101,'MOHAN','ADMIN',4000) ;
INSERT INTO EMPLOYEES VALUES(102,'RAJKUMAR','HR',3000) ;
INSERT INTO EMPLOYEES VALUES(103,'AKBAR','IT',4000) ;
INSERT INTO EMPLOYEES VALUES(104,'DORVIS','FINANCE',6500) ;
INSERT INTO EMPLOYEES VALUES(105,'ROHIT','HR',3000) ;
INSERT INTO EMPLOYEES VALUES(106,'RAJESH','FINANCE',5000) ;
INSERT INTO EMPLOYEES VALUES(107,'PREET','HR',7000) ;
INSERT INTO EMPLOYEES VALUES(108,'MARYAM','ADMIN',4000) ;
INSERT INTO EMPLOYEES VALUES(109,'SANJAY','IT',6500) ;
INSERT INTO EMPLOYEES VALUES(110,'VASUDHA','IT',7000) ;
INSERT INTO EMPLOYEES VALUES(111,'MALINDA','IT',8000) ;
INSERT INTO EMPLOYEES VALUES(112,'KOMAL','IT',10000) ;
INSERT INTO EMPLOYEES VALUES(113,'GAUTAM','ADMIN',2000) ;
INSERT INTO EMPLOYEES VALUES(114,'MANISH','HR',3000) ;
INSERT INTO EMPLOYEES VALUES(115,'CHANDNI','IT',4500) ;
INSERT INTO EMPLOYEES VALUES(116,'SATYA','FINANCE',6500) ;
INSERT INTO EMPLOYEES VALUES(117,'AADARSH','HR',3500) ;
INSERT INTO EMPLOYEES VALUES(118,'TEJASWI','FINANCE',5500) ;
INSERT INTO EMPLOYEES VALUES(119,'CORY','HR',8000) ;
INSERT INTO EMPLOYEES VALUES(120,'MONICA','ADMIN',5000) ;
INSERT INTO EMPLOYEES VALUES(121,'ROSALIN','IT',6000) ;
INSERT INTO EMPLOYEES VALUES(122,'IBRAHIM','IT',8000) ;
INSERT INTO EMPLOYEES VALUES(123,'VIKRAM','IT',8000) ;
INSERT INTO EMPLOYEES VALUES(124,'DHEERAJ','IT',11000) ;

SELECT * FROM EMPLOYEES ;

--Creation of Product Table and inserting values into it 
CREATE TABLE PRODUCT(
PRODUCT_CATEGORY VARCHAR(250) ,
BRAND VARCHAR(250) ,
PRODUCT_NAME VARCHAR(250) ,
PRICE INTEGER);


INSERT INTO PRODUCT VALUES('Phone','Apple','iphone 12 Pro Max' ,1300) ;
INSERT INTO PRODUCT VALUES('Phone','Apple','iphone 12 Pro ' ,1100) ;
INSERT INTO PRODUCT VALUES('Phone','Apple','iphone 12 ' ,1000) ;
INSERT INTO PRODUCT VALUES('Phone','Samsung','Galaxy Z Fold 3 ' ,1800) ;
INSERT INTO PRODUCT VALUES('Phone','Samsung','Galaxy Z Flip 3 ' ,1000) ;
INSERT INTO PRODUCT VALUES('Phone','Samsung','Galaxy Note 20 ' ,1200) ;
INSERT INTO PRODUCT VALUES('Phone','Samsung','Galaxy S21' ,1000) ;
INSERT INTO PRODUCT VALUES('Phone','OnePlus','One Plus Nord' ,300) ;
INSERT INTO PRODUCT VALUES('Phone','OnePlus','One Plus 9' ,800) ;
INSERT INTO PRODUCT VALUES('Phone','Google ','Pixel 5' ,600) ;
INSERT INTO PRODUCT VALUES('Laptop','Apple','MacBook Pro 3' ,2000) ;
INSERT INTO PRODUCT VALUES('Laptop','Apple','MacBook Air' ,1200) ;
INSERT INTO PRODUCT VALUES('Laptop','Microsoft','Surface Laptop 4' ,2100) ;
INSERT INTO PRODUCT VALUES('Laptop','Deil','XPS 13' ,2000) ;
INSERT INTO PRODUCT VALUES('Laptop','Deil','XPS 15' ,2300) ;
INSERT INTO PRODUCT VALUES('Laptop','Deil','XPS 17' ,2500) ;
INSERT INTO PRODUCT VALUES('EarPhone','Apple','AirPods Pro' ,280) ;
INSERT INTO PRODUCT VALUES('EarPhone','Samsung','Galaxy Buds Pro' ,220) ;
INSERT INTO PRODUCT VALUES('EarPhone','Samsung','Galaxy Buds Live' ,170) ;
INSERT INTO PRODUCT VALUES('EarPhone','Sony','WF-1000XM4' ,250) ;
INSERT INTO PRODUCT VALUES('HeadPhone','Sony','WF-1000XM4' ,400) ;
INSERT INTO PRODUCT VALUES('HeadPhone','Apple','Airpods - MAX' ,550) ;
INSERT INTO PRODUCT VALUES('HeadPhone','Microsoft','Surface HeadPhones 2' ,250) ;
INSERT INTO PRODUCT VALUES('Smart Watch','Apple','Apple Watch Series 6' ,1000) ;
INSERT INTO PRODUCT VALUES('Smart Watch','Apple','Apple Watch SE' ,400) ;
INSERT INTO PRODUCT VALUES('Smart Watch','Samsung','Galaxy Watch 4' ,600) ;
INSERT INTO PRODUCT VALUES('Smart Watch','OnePlus','OnePlus Watch' ,220) ;


Select * from PRODUCT ;

--1. AGGREGATE WINDOW FUNCTION

--MAX SALARY EARNED BY AN EMPLOYEE 
SELECT MAX(SALARY) AS MAX_SAL FROM EMPLOYEES ;

--FINDOUT MAX SALARY WITHIN EACH DEPARTMENT 
SELECT DEPT_NAME , MAX(SALARY) FROM EMPLOYEES GROUP BY DEPT_NAME ;

--FINDOUT MAX SALARY WITHIN EACH DEPARTMENT ALONGSIDE THE OTHER DETAILS OF THE EMPLOYEES 

SELECT E.* ,
MAX(SALARY) OVER(PARTITION BY DEPT_NAME) AS MAX_SAL
FROM EMPLOYEES E ;  --OVER CLAUSE IS USED TO CREATE A WINDOW 

SELECT E.* ,
MAX(SALARY) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS MAX_SAL
FROM EMPLOYEES E ; --FOR ORDERING BY EMP_ID

--FINDOUT MIN SALARY WITHIN EACH DEPARTMENT ALONGSIDE THE OTHER DETAILS OF THE EMPLOYEES 
SELECT E.* ,
MIN(SALARY) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS MIN_SAL
FROM EMPLOYEES E ;

--FINDOUT SUM OF SALARY WITHIN EACH DEPARTMENT ALONGSIDE THE OTHER DETAILS OF THE EMPLOYEES 
SELECT E.* ,
SUM(SALARY) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS TOTAL
FROM EMPLOYEES E ;

--FINDOUT COUNT OF EMPLOYEES WITHIN EACH DEPARTMENT ALONGSIDE THE OTHER DETAILS OF THE EMPLOYEES 
SELECT E.* ,
COUNT(EMP_ID) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID ) AS NO_OF_EMPLOYEES
FROM EMPLOYEES E ;

--FINDOUT AVERAGE SALARY WITHIN EACH DEPARTMENT ALONGSIDE THE OTHER DETAILS OF THE EMPLOYEES 
SELECT E.* ,
AVG(SALARY) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS AVG_SAL
FROM EMPLOYEES E ;



-- 2. RANKING WINDOW FUNCTIONS 
--  WINDOW FUNCTION : ROW_NUMBER() 
--IT IS USED TO ASSIGN A UNIQUE VALUE TO EACH RECORD WITHIN A TABLE 
SELECT E.* ,
ROW_NUMBER() OVER() AS RN
FROM EMPLOYEES E ;


-- UNIQUE VALUE BY DEPARTMENT NAME
SELECT E.* ,
ROW_NUMBER() OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS RN
FROM EMPLOYEES E ;

--SELECT THE PREVIOUS TOPMOST 2 EMPLOYEES (THE PREVIOUS EMPLOYEE'S EMP_ID IS LOWER THAN THE NEW ONE ) 
SELECT * FROM
     (SELECT E.* ,
      ROW_NUMBER() OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS RN
      FROM EMPLOYEES E ) X
WHERE X.RN < 3 ;

--  WINDOW FUNCTION : RANK() 
-- WHENEVER RANK FINDS A DUPLICATE VALUE , IT'S ASSIGN THE SAME VALUE TO THE RECOD BUT FOR EVERY DUPLICATE RECORD IT SKIPS ONE VALUE IN DESCENDING ORDER .

--FETCH EMPLOYEES IN EACH DEPARTMENT ORDER BY SALARY DESC
SELECT E.* ,
RANK() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS RNK
FROM EMPLOYEES E ;

--FETCH TOP 3 EMPLOYEES IN EACH DEPARTMENT EARNING THE MAX SALARY
SELECT * FROM 
       (SELECT E.* ,
        RANK() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS RNK
        FROM EMPLOYEES E ) X
WHERE X.RNK < 4 ;

--  WINDOW FUNCTION : DENSE_RANK() 
-- WHENEVER DENSE_RANK FINDS A DUPLICATE VALUE , IT'S ASSIGN THE SAME VALUE TO THE RECOD AND FOR EVERY DUPLICATE RECORD IT DOES NOT SKIP VALUE AS LIKE RANK .

--FETCH EMPLOYEES IN EACH DEPARTMENT ORDER BY SALARY DESC
SELECT E.* ,
RANK() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS RNK,
DENSE_RANK() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS DENSE_RNK
FROM EMPLOYEES E ;

--FETCH TOP 3 EMPLOYEES IN EACH DEPARTMENT EARNING THE MAX SALARY
SELECT * FROM 
       (SELECT E.* ,
        RANK() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS RNK,
        DENSE_RANK() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS DENSE_RNK
        FROM EMPLOYEES E ) X
WHERE X.RNK < 4 ;

-- ROW_NUMBER(),RANK(),DENSE_RANK() DOES NOT TAKE A PARAMETER , IT JUST ASSIGNS A VALUE BASED ON WHAT IS GIVEN IN THE OVER CLAUSE
SELECT E.* ,
RANK() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS RNK,
DENSE_RANK() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS DENSE_RNK,
ROW_NUMBER() OVER(PARTITION BY DEPT_NAME ORDER BY SALARY DESC) AS RN
FROM EMPLOYEES E ;

-- WINDOW FUNCTION - NTILE()

--IT GROUPS THE PARTTION INTO THE GROUP OF BUCKETS , AND THE NUMBER OF  BUCKETS IS GIVEN IN THE NTILE() FUNCTION . IT TRIES TO DIVIDE EQUAL VAALUES IN EACH BUCKET .

-- WRITE A QUERY TO SEGREGATE ALL THE EXPENSIVE PHONES , MID RANGE PHONES AND CHEAPER PHONES .
SELECT PRODUCT_NAME ,
CASE WHEN X.BUCKETS=1 THEN 'EXPENSIVE PHONES' 
     WHEN X.BUCKETS=2 THEN 'MID RANGE PHONES' 
     WHEN X.BUCKETS=3 THEN 'CHEAPER PHONES' END PHONE_CATEGORY
FROM ( SELECT * ,
      NTILE(3) OVER(ORDER BY PRICE DESC) AS BUCKETS
      FROM PRODUCT
      WHERE PRODUCT_CATEGORY='PHONE') X;

-- 3. VALUE(OFFSET) WINDOW  FUNCTIONS
--  WINDOW FUNCTION : LAG() 

--USED TO FIND THE PREVIOUS COLUMN VALUE BASED ON EXPRESSION , OFFSET AND DEFAULT VALUE 
SELECT E.* ,
LAG(SALARY,1,0) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS PRE_EMP_SAL
FROM EMPLOYEES E ;

SELECT E.* ,
LAG(SALARY,2,0) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS PRE_EMP_SAL
FROM EMPLOYEES E ;

--FETCH THE QUERY TO DISPLAY IF THE SALARY OF AN EMPLOYEE IS HIGHER , LOWER OR EQUAL TO THE PREVIOU EMPLOYEE
SELECT E.* ,
LAG(SALARY,1) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS PRE_EMP_SAL,
CASE WHEN LAG(SALARY,1) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) IS NULL THEN 'NO RECORD '
     WHEN E.SALARY > LAG(SALARY,1,0) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID)  THEN 'HIGHER THAN THE PREVIOUS EMPLOYEE'
     WHEN E.SALARY < LAG(SALARY,1,0) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID)  THEN 'LOWER THAN THE PREVIOUS EMPLOYEE'
     WHEN E.SALARY = LAG(SALARY,1,0) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID)  THEN 'EQUALTHE PREVIOUS EMPLOYEE'
END SAL_STATUS
FROM EMPLOYEES E ;


--  WINDOW FUNCTION : LEAD() 

--USED TO FIND THE FOLLOWING COLUMN VALUE BASED ON EXPRESSION , OFFSET AND DEFAULT VALUE 
SELECT E.* ,
LEAD(SALARY,1,0) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS NEXT_EMP_SAL
FROM EMPLOYEES E ;

SELECT E.* ,
LEAD(SALARY,2,0) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS NEXT_EMP_SAL
FROM EMPLOYEES E ;


SELECT E.* ,
LAG(SALARY,1,0) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS PRE_EMP_SAL,
LEAD(SALARY,1,0) OVER(PARTITION BY DEPT_NAME ORDER BY EMP_ID) AS NEXT_EMP_SAL
FROM EMPLOYEES E ;


--WINDOW FUNCTION - FIRST_VALUE 

--FIRST_VALUE FETCH THE VALUE OR COLUMN FROM THE VERY FIRST RECORD .

--WRITE THE QUERY TO DISPLAY THE MOST EXPENSIVE PRODUCT UNDER EACH CATEGORY(CORRESPONDING TO EACH RECORD) 
SELECT * ,
FIRST_VALUE(PRODUCT_NAME) OVER (PARTITION BY PRODUCT_CATEGORY ORDER BY PRICE DESC) AS MOST_EXP_PRODUCT
FROM PRODUCT ;

/*NOTE : FRAME CLUASE : A WINDOW IS FURTHER DIVIDED INTO PARTITIONS AND A PARTITON IS FURTHER DIVIDED INTO FRAMES . SO ,
WHEN WE ARE USING THE LAST_VALUE(), NTH_VALUE() , AGGREGATE FUNCTIONS THEN THE CURRENT DEFAULT FRAME CAN'T SATISHFY THE CONDITION . THE DEFAULT FRAME IS
{RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW } . HERE THE UNBOUNDED PRECEDING MEANS THE STARTING FIRST RECORD OF THE PARTITION . SO , IN THE LAST_VALUE FUNCTION
WHILE USING THE DEFAULT ONE , IT TAKES THE FIRST ROW AS UNBOUNDED PRECEDING AND THE CURRENT ROW AND PRINT THE LAST VALUE OF THAT RANGE , THAT'S WHY IT PRINTS DIFFERENT 
VALUE FOR DIFFERENT RECORDS UNDER THE SAME PARTITION . BUT WHEN WE CHANGE THE CURRENT ROW WITH THE UNBOUNDED FOLLOWING THEN IT CONSIDERES THE WHOLE PARTITION AS A RANGE AND 
UNBOUNDED FOLLOWING MEANS THE VERY LAST RECORD OF THAT PARTTION . SO , IT WILL PRINT SIMILAR LAST VALUE FOR EVERY RECORD .

WE CAN CHANGE THE STARTING RANGE WITH ROWS . 
THE ONLY DIFFERENCE BETWEEN THE RANGE AND ROWS IS THIS RANGE CONSIDERES ONE LAST VALUE FOR EACH DUPLICATE VALUE VIA WHICH THE ORDEREDING IS DONE IN THE CURRENT ROW . WHILE THE 
ROWS WILL TREAT EVERY DUPLICATE RECORD AS A CURRENT UNIQUE ROW .  

WE CAN ALSO SPECIFY LIKE {RANGE BETWEEN 2 PRECEDING AND 2 FOLLOWING } THIS WILL CREATE A FRAME OF 5 ROWS . THE RANGE FRAME WILL BE  ADDED IN THE LAST IN THE OVER CLAUSE .
*/

--WINDOW FUNCTION - LAST_VALUE 

--LAST_VALUE WOULD FETCH THE VALUE OR THE COLUMN FROM THE VERY LAST RECORD .

--WRITE THE QUERY TO DISPLAY THE LEAST EXPENSIVE PRODUCT UNDER EACH CATEGORY(CORRESPONDING TO EACH RECORD) 

--SIMPLE LAST_VALUE FUNCTION APPLICATION
SELECT * ,
LAST_VALUE(PRODUCT_NAME) OVER (PARTITION BY PRODUCT_CATEGORY ORDER BY PRICE DESC) AS LEAST_EXP_PRODUCT
FROM PRODUCT ;

--EXAMPLE OF THE DEFAULT FRAME
SELECT * ,
LAST_VALUE(PRODUCT_NAME) OVER (PARTITION BY PRODUCT_CATEGORY ORDER BY PRICE DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS LEAST_EXP_PRODUCT
FROM PRODUCT ;

-- CORRECT WAY OF APPLYING LAST_VALUE VIA A LITTLE BIT CHANGE IN THE DEFAULT FRAME
SELECT * ,
LAST_VALUE(PRODUCT_NAME) OVER (PARTITION BY PRODUCT_CATEGORY ORDER BY PRICE DESC RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS LEAST_EXP_PRODUCT
FROM PRODUCT ;

--EXAMPLE OF THE DUPLICACY VIA THE  RANGE
SELECT * ,
LAST_VALUE(PRODUCT_NAME) OVER (PARTITION BY PRODUCT_CATEGORY ORDER BY PRICE DESC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS LEAST_EXP_PRODUCT
FROM PRODUCT
WHERE PRODUCT_CATEGORY='PHONE';

--EXAMPLE OF THE DUPLICACY VIA ROWS 
SELECT * ,
LAST_VALUE(PRODUCT_NAME) OVER (PARTITION BY PRODUCT_CATEGORY ORDER BY PRICE DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS LEAST_EXP_PRODUCT
FROM PRODUCT
WHERE PRODUCT_CATEGORY='PHONE';

--NOT SUPPORTED IN SSMS BUT IN POSTGRESQL
SELECT * ,
LAST_VALUE(PRODUCT_NAME) OVER (PARTITION BY PRODUCT_CATEGORY ORDER BY PRICE DESC RANGE BETWEEN 2  PRECEDING AND 2 FOLLOWING) AS LEAST_EXP_PRODUCT
FROM PRODUCT ;

--ALTERNATE WAY OF WRITING A WINDOW FUNCTION
/*WHEN WE USE MULTIPLE WINDOW FUNCTION IN A QUERY THEN IN MOST OF THE CASES THE CONDITION WRITTEN IN THE OVER CLAUSE IS SAME , SO , WE CAN USE THE WINDOW CLAUSE AT THE END OF THE 
QUERY BUT BEFORE THE ORDER BY CLAUSE AND THEN WE CAN GIVE IT A ALIAS AND WE CAN USE THAT ALIAS IN THE OVER . */

SELECT * ,
FIRST_VALUE(PRODUCT_NAME) OVER W AS MOST_EXP_PRODUCT,
LAST_VALUE(PRODUCT_NAME) OVER W AS LEAST_EXP_PRODUCT
FROM PRODUCT
WINDOW W AS (PARTITION BY PRODUCT_CATEGORY ORDER BY PRICE DESC RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING);


--WINDOW FUNCTION - NTH_VALUE 

--NTH_VALUE CAN FETCH THE VALUE OR THE COLUMN FROM ANY RECORD THAT YOU SPECIFY .

--WRITE THE QUERY TO DISPLAY THE SECOND MOST EXPENSIVE PRODUCT UNDER EACH CATEGORY(CORRESPONDING TO EACH RECORD) .nth_value(column name , offset) , 
--If the offset value is out of range then it returns null .

-- Not supported in  SSMS
/*SELECT * ,
FIRST_VALUE(PRODUCT_NAME) OVER W AS MOST_EXP_PRODUCT,
LAST_VALUE(PRODUCT_NAME) OVER W AS LEAST_EXP_PRODUCT ,
NTH_VALUE(PRODUCT_NAME,2) OVER W AS SECOND_MOST_EXP_PRODUCT 
FROM PRODUCT
WINDOW W AS (PARTITION BY PRODUCT_CATEGORY ORDER BY PRICE DESC RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING);*/

--For checking the version
select @@VERSION ;

-- 5. STATISTICAL WINDOW FUNCTIONS

--WINDOW FUNCTION - CUME_DIST(CUMULATIVE DISTRIBUTION)
/*VALUE --> 1 <= CUME_DIST >0 */
/* FORMULA = CURRENT ROW NO (OR ROW WITH VALUE SAME AS CURRENT ROW ) / TOTAL NO OF ROWS */ 

--QUERY TO FETCH ALL PRODUCTS WHICH ARE CONSTITUTING THE FIRST 30%
--OF THE DATA IN PRODUCTS TABLE BASED ON PRICE



